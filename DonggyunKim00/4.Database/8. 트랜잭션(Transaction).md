# DB 트랜잭션(Transaction)

> 트렌잭션이란?
> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위

상태를 변화시킨다는 것 → SQL 질의어를 통해 DB에 접근하는 것

```ABAP
- SELECT
- INSERT
- DELETE
- UPDATE
```

작업 단위 → 많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것

```ABAP
예시) 사용자 A가 사용자 B에게 만원을 송금한다.

* 이때 DB 작업 *
- 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
- 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경

현재 작업 단위: 출금 UPDATE문 + 입금 UPDATE문
→ 이를 통틀어 하나의 트랜잭션이라고 한다.
- 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이
  완료되는 것이다. `Commit`
- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고
  이전 상태로 돌려놓아야한다. `Rollback`

즉, 하나의 트랜잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져다준다.
```

### 트랜잭션 특징(ACID)

1. **원자성(Atomicity)** : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.

2. **일관성(Consistency)** : 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.

3. **독립성(Isolation)** : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.

4. **지속성(Durability)** : 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

### 트랜잭션의 연산

- `Commit`

  - 하나의 트랜잭션이 성공적으로 종료된 후, 데이터베이스가 일관된 상태를 유지할 때 갱신 연산이 완료되었다고 트랜잭션 관리자에게 알려줌
  - 결과를 최종적으로 데이터베이스에 반영함

- `Rollback`
  - 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우
  - 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션 수행 이전의 상태로 돌아감

`상황이 주어지면 DB 측면에서 어떻게 해결할 수 있을지 대답할 수 있어야 함`

### Transaction 관리를 위한 DBMS의 전략

1. **DBMS의 구조**

   - 크게 2가지 : Query Processor (질의 처리기), Storage System (저장 시스템)
   - 입출력 단위 : 고정 길이의 page 단위로 disk에 읽거나 쓴다.
   - 저장 공간 : 비휘발성 저장 장치인 disk에 저장, 일부분을 Main Memory에 저장

2. **Page Buffer Manager or Buffer Manager**

   - DBMS의 Storage System에 속하는 모듈 중 하나로, Main Memory에 유지하는 페이지를 관리하는 모듈
   - Buffer 관리 정책에 따라, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 가져온다.
   - Buffer Manager는 이 데이터를 메모리에 어떻게 유지하고 디스크에 언제 쓰는지 결정하기 때문에 **이 시점 결정이 트랜잭션 복구 전략(UNDO, REDO)에 직접 영향을 준다**

3. **UNDO**

   - 트랜잭션이 비정상 종료되었을 때 그 트랜잭션이 변경한 데이터를 원래대로 되돌리는 작업
   - 예: 돈 이체 중 오류가 나면, 출금된 금액을 원래 계좌로 다시 넣어주는 것
   - steal 정책: 변경된 페이지를 중간에 디스크에 쓸 수 있음 (UNDO 필요)
   - no-steal 정책: 트랜잭션이 끝날 때까지 디스크에 쓰지 않음 (UNDO 불필요)

4. **REDO**
   - 트랜잭션이 정상적으로 종료되었지만, 해당 내용이 디스크에 완전히 저장되지 않았다면? → 그걸 다시 반영하는 작업
   - force 정책: 커밋되면 무조건 디스크에 저장 (REDO 불필요)
   - no-force 정책: 커밋되어도 나중에 저장될 수 있음 (REDO 필요)

`즉, 대부분의 DBMS는 steal + no-force 조합을 쓰기 때문에
UNDO와 REDO 둘 다 필요하다`
