# DB Index

## 목적
- RDBMS에서 **검색 속도**를 높이기 위한 기술
- 테이블의 컬럼을 색인화하여 별도의 인덱스 파일로 저장
- 인덱스를 사용하면 테이블 전체를 Full Scan하지 않아도 됨
- 보통 **B+ Tree 구조**를 사용하여 빠른 탐색 지원

## 인덱스 파일 구성
테이블을 생성하면 아래와 같은 파일이 생성됨:

- `FRM`: 테이블 구조 저장
- `MYD`: 실제 데이터 저장
- `MYI`: 인덱스 정보 저장

> 인덱스를 사용하지 않으면 MYI는 비어 있음  
> 인덱스를 생성하면 MYI 파일이 갱신되고, SELECT 시 MYI를 기준으로 탐색

## 단점
- 인덱스를 만들면 `.mdb` 파일 크기 증가
- 병행성(concurrency) 저하 (같은 페이지 동시에 수정 어려움)
- 인덱스가 걸린 필드에 대해 `INSERT`, `UPDATE`, `DELETE`가 많을수록 성능 저하
- 변경이 잦은 컬럼은 인덱스가 오히려 역효과

## 인덱스를 사용하면 좋은 경우
1. WHERE 절에서 자주 사용하는 컬럼
2. 외래키(Foreign Key)가 걸린 컬럼
3. JOIN에 자주 사용되는 컬럼

## 인덱스를 피해야 하는 경우
1. 중복도가 높은 컬럼 (예: 성별, 국가 등)
2. DML(INSERT, UPDATE, DELETE)이 자주 발생하는 컬럼

## DML 작업 시 영향

### INSERT
- 기존 블록에 공간이 없으면 새 블록 할당
- 인덱스 키 재배치 필요 → 많은 Redo 발생
- **Index Split** 작업 발생 → 해당 블록의 DML 작업이 블로킹됨

### DELETE
- 테이블: 데이터 삭제 후 공간 재사용 가능
- 인덱스: 삭제된 데이터를 실제로 지우지 않고 **사용 안 함** 표시만 함
- 결과적으로 테이블과 인덱스 간 데이터 수 불일치 발생 가능

### UPDATE
- 인덱스는 직접 수정 불가 → 기존 데이터 삭제 후 새로운 값 삽입
- DELETE + INSERT로 처리되므로 **2배 작업량** 발생
