# 페이지 교체 알고리즘

## 개요
- 페이지 부재(Page Fault)가 발생했을 때, 새로운 페이지를 메모리에 올리기 위해 기존 페이지 중 어떤 것을 교체할지를 결정하는 알고리즘
- 교체 대상 페이지를 **Victim Page**라고 한다

---

## 왜 페이지 교체 알고리즘이 필요한가?

- 가상 메모리는 필요한 페이지만 메모리에 올리는 **요구 페이징(Demand Paging)** 방식을 사용
- 메모리가 가득 차면, 더 이상 페이지를 올릴 수 없기 때문에 **안 쓰는 페이지를 교체**해야 한다
- 특히 수정되지 않은 페이지가 교체 대상이면 성능상 유리하다 (디스크 쓰기 작업 줄어듦)

---

## Page Reference String
- CPU는 논리 주소를 통해 특정 페이지를 요구
- 요구된 페이지 번호를 나열한 문자열이 **Page Reference String**
- 연속된 페이지 요청 중 메모리에 이미 있는 경우는 생략 가능

---

## 주요 페이지 교체 알고리즘

### FIFO (First-In First-Out)
![image](https://github.com/user-attachments/assets/82d5bb14-4e6d-48fb-bcde-ac5ea4764995)

- 가장 먼저 메모리에 올라온 페이지를 가장 먼저 교체
- 초기화 코와 같은 일회성 코드 처리에 유리
- 단점: 자주 사용하는 페이지라도 먼저 들어왔으면 교체될 수 있음

### OPT (Optimal)
![image](https://github.com/user-attachments/assets/15a142d9-d75f-4fc0-859d-5692d556a25d)
- **앞으로 가장 오랫동안 사용되지 않을 페이지**를 교체
- 페이지 결함 횟수가 가장 적지만, **미래 예측이 필요**해 실제 구현은 어렵다

### LRU (Least Recently Used)
![image](https://github.com/user-attachments/assets/e15574ce-f581-42ca-a03f-e6d6487bf763)
- **최근에 가장 오랫동안 사용되지 않은 페이지**를 교체
- OPT보다 결함 횟수는 많을 수 있지만, 현실적으로 가장 널리 쓰이는 알고리즘
- 과거 사용 기록을 기반으로 하기 때문에 실제 구현이 가능하다

---

## 교체 방식

### Global Replacement
- **모든 프로세스의 페이지** 중에서 교체할 페이지를 선택
- 일반적으로 더 효율적

### Local Replacement
- **해당 프로세스의 페이지** 중에서만 교체
- 각 프로세스가 자신의 메모리를 독립적으로 관리할 수 있음
- 하지만 전체 효율 측면에서는 비효율적일 수 있음

---

## 요약

- 페이지 교체 알고리즘은 가상 메모리 성능에 큰 영향을 줌
- 가장 실용적인 방식: **LRU**
- 가장 이상적인 방식: **OPT**, 하지만 현실 구현 불가
- 교체 방식도 **Global**이 일반적으로 성능이 더 좋음
