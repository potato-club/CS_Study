# 💻 트랜잭션 격리 수준

---

## 1. ✅ isloation level

> 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준

- 필요성
  - 데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인  수행을 하도록 한다.
  - 따라서 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는것이 필요하다.
  - 하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션을 순서대로 처리 하는 방식으로 구현하게 되면 데이터베이스 성능은 떨어진다.
  - 따라서 최대한 효율적인 Locking이 필요하다.

## 2. ✅ isolation level 종류

1. Read Uncommitted (레벨 0)
> SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층
> 
> 트랜잭션 처리중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함 -> 디비 일관성 유지 불가능


2. Read Committed (레벨 1)
> SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층
> 
> 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨,
> Commit이 이루어진 트랜잭션만 조회 가능
> 
> 대부분의 SQL 서버가 Default로 사용하는 isolation level



3. Repeatable Read (레벨 2)
> 트랜잭션이 완료될 떄까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
> 
> 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함, 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
> 
> MySQL에서는 Default로 isolation level

4. Serializable (레벨 3)
> 트랜잭션이 완료될 떄까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
> 
>  완벽한 읽기 일관성 모드를 제공한다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능

## 3. ✅ 선택 시 고려사항
- isolation level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있다.
- 동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 된다. 레벨이 높아질수록 발생하는 비용 증가

**낮은 단계 isolation level을 활용할 때 발생하는 현상들**
- Dirth Read
  - 커밋이 되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을때 발생하는 현상 
  - 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우
    - 발생 level: Read Uncommitted
- Non-Repeatable Read
  - 한 트랜잭션에서 같은 쿼리를 두번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상
    - 발생 level : Read Committed, Read UnCommitted
- Phantom Read
  - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
  - 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임
    - 발생 level : Repeatable Read, Read Committed, Read UnCommitted

---

# 🤔 질문

### 1. 왜 격리 수준이 필요한가?
- Locking을 엄격하게 걸거나 느슨하게 걸경우 디비가 느려질 수 있기에 이를 조절한다

### 2. MySQL의 격리수준은?
- Repeatable read 레벨이다.

### 3. 