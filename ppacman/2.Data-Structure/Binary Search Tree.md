# 이진 탐색 트리

> 이진탐색 : 탐색에 소요되는 시간복잡도는 O(logN), but 삽입,삭제가 불가능
> 연결리스트 : 삽입, 삭제의 시간복잡도는 O(1), but 탐색하는 시간복잡도가 O(N)

이 두가지를 합하여 장점을 모두 얻는 것이 '이진탐색트리'
즉, 효율적인 탐색 능력을 가지고, 자료의 삽입 삭제도 가능하게 만들자

## 조건

- 각 노드의 자식이 2개 이하
- 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큼
- 중복된 노드가 없어야 함
  이 조건들을 충족시키지 못할 경우 검색 효율이 현저하게 떨어지기 때문에 이 형태를 벗어난다면 다른 탐색 기법을 활용하는것이 더 좋음

  > 이진탐색 트리의 순회는 '중위순회'를 이용한다

## 핵심 연산

> const values = [10, 5, 15, 3, 7];

1. 탐색

```
루트부터 시작해서,
찾는 값이 현재 노드보다 작으면 왼쪽
크면 오른쪽 자식으로 계속 탐색
이 과정은 트리의 깊이만큼 반복
시간 복잡도: O(logN) (트리가 균형 잡힌 경우)
```

2.삽입

```
탐색하듯 내려가다가, 빈 자리를 만나면 거기에 새 노드 삽입
정렬 조건 (왼 < 부모 < 오)을 유지해야 함
시간 복잡도: O(logN) (균형 트리 기준)

```

3. 삭제

```
📌 Case 1: 자식이 없는 Leaf 노드
그냥 그 노드 삭제하면 끝
📌 Case 2: 자식이 한 개 있는 노드
그 자식을 삭제할 노드 자리로 올려서 연결만 바꿔주면 됨
📌 Case 3: 자식이 두 개 있는 노드
이게 제일 중요함
삭제할 노드 대신에  "대체 노드" 를 찾아야 함
오른쪽 서브트리에서 가장 작은 값 또는
왼쪽 서브트리에서 가장 큰 값
그 값을 현재 노드로 옮기고, 원래 자리의 노드는 삭제하는 식
✨왜 이렇게 하냐? → BST 정렬 조건을 유지하기 위해서야
```
