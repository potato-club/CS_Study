# 메인 메모리

주 기억 장치
cpu가 직접 접근해서 명령어를 가져오고, 데이터를 읽고 쓸 수 있는 공간
자가업 중인 파일을 입시로 저장하는 책상 같은 역할, 프로그램이 실행되려면 반드시 메모리에 올라와 있어야 한다

# MMU (Memory Management Unit)

메인 메모리와 CPU 사이에서 주소 변환과 보호를 담당하는 하드웨어 장치

1. 가상 주소 -> 물리 주소로 변환
   프로그램은 가상 주소를 사용하지만, 실제 데이터는 물리 주소에 저장됨 -> 이걸 매핑해줌
   더 많은 메모리를 보여주기 위해
   또한 메인 메모리의 직접 접근은 비효율적이므로, CPU와 메인 메모리 속도를 맞추기 위해 캐시가 존재함
2. 메모리 보호
   프록램이 자기 메모리만 접근하게 제한함. 남의 메모리에 접근하려고 하면 오류 발생
   base , limit 레지스터를 이용한 메모리 보호 기법
   base 레지스터는 메모리상의 프로세스 시작주소를 물리 주소로 저장 limit 레지스터는 프로세스의 사이즈를 저장
   > base <= x < base + limit 이 영역 안에서만 접근 가능함
3. 페이징 시스템 지원
   `메모리 과할당`

   > 실제 메모리의 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황

   과할당이 들킬만한 상황 존재

   1. 프로세스 실행 도중 페이지 폴트 발생
   2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
   3. 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음

이런 과할당을 해결하지 위해서, 빈 프레임을 확보할 수 있어야함

1. 메모리에 올라와 있는 한 프로세스를 종료시켜 빈 프레임을 얻음
2. 프로세스 하나를 swap out하고, 이 공간을 빈 프레임으로 활용
   swapping 기법을 통해 공간을 바꿔치기하는 2번 방법과는 달리 1번은 사용자에게 페이징 시스템을 들킬 가능성이 매우 높아서 하면 안됨

### 페이지 교체

> 메모리 과할당이 발생했을 때, 프로세스 하나를 swap out해서 빈 프레임을 확보하는 것

1. 프로세스 실행 도중 페이지 부재 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리에 빈 프레임이 있는지 확인
   - 빈 프레임이 있으면 해당 프레임을 사용
   - 빈 프레임이 없으면, victim 프레임을 선정해 디스크에 기록하고 페이지 테이블을 업데이트함
4. 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고, 페이지 테이블 업데이트

이 페이지 교체를 사용자가 알지 못하도록 해야하기 때문에 , 오버헤드가 가장 적은 페이지 교체를 해야함

### 방법1

변경 비트 (Dirty Bit)란?

- 각 페이지마다 1비트의 플래그를 둡니다.
- 이 비트는 해당 페이지가 메모리에 올라온 이후 수정되었는지 여부를 나타냅니다.
  - 1 (Set): 메모리 상의 페이지가 수정되었음 → 디스크에 저장해야 함
  - 0 (Clear): 수정되지 않았음 → 디스크 저장 생략 가능
    흐름

1. 페이지가 메모리에 올라옴 → Dirty Bit = 0 (초기화)
2. CPU가 해당 페이지에 쓰기(write) 작업을 수행 → Dirty Bit = 1
3. 교체 대상 페이지(victim page)가 선택됨
4. 해당 페이지의 Dirty Bit를 확인
   - Bit = 1 → 디스크에 기록 후 제거
   - Bit = 0 → 디스크 기록 없이 제거

### 방법 2

페이징 교체 기법
전에 정리한 내용

## 캐싱 라인

캐싱 라인은 캐시 메모리에 데이터를 저장할 때 사용하는 기본 단위 블록입니다.
단순히 "데이터 하나"를 저장하는 게 아니라, 그 데이터를 포함한 일정 범위의 연속된 메모리 덩어리를 하나의 단위로 묶어서 저장합니다.
