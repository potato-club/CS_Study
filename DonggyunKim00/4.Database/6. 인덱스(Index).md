# Index (DB Index)

### 1. 목적

> RDBMS에서 검색 속도를 높이기 위한 기술

- Table의 Column을 색인화 함 (따로 파일로 저장)
- 해당 Table의 Record를 Full scan 하지 않음.
- 색인화 된 (B+ Tree 구조로) Index 파일 검색으로 검색 속도 향상

### 2. 과정

> Table을 생성하면, MYD, MYI, FRM 3개의 파일이 생성됨.

- FRM : 테이블 구조가 저장되어 있는 파일
- MYD : 실제 데이터가 있는 파일
- MYI : Index 정보가 들어가 있는 파일

Index를 사용하지 않는 경우, MYI 파일은 비어져 있음. 그러나, 인덱싱하는 경우 MYI 파일이 생성됨.
이후에 사용자가 **Select 쿼리로 Index를 사용하는 Column을 탐색 시, MYI 파일의 내용을 검색**함.

### 3. 단점

- Index 생성시, .mdb 파일 크기가 증가함
- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듬.
- 인덱스 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 떨어짐.
- 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로, 성능에 영향을 미침.

### 4. 상황 분석

- 사용하면 좋은 경우

  1. Where 절에서 자주 사용되는 Column
  2. 외래키가 사용되는 Column
  3. Join에 자주 사용되는 Column

- Index 사용을 피해야 하는 경우
  1. Data 중복도가 높은 Column
  2. DML이 자주 일어나는 Column

### 5. DML이 일어났을 때의 상황

1. `INSERT`

- 새로운 데이터를 추가하려고 하면, 인덱스에도 그 값을 추가해야 함.
- 그런데 해당 인덱스 블록에 여유 공간이 없으면, 블록을 쪼개야 함 → Index Split
- 이 과정에서:
  - 새로운 블록 할당
  - 기존 키 재배치 (키 이동)
  - Redo 로그가 많이 발생 (복구를 위한 기록)
  - 해당 키 범위에 대해 DML이 잠깐 블로킹됨 (대기)

2. `DELETE`

- 테이블에서는 데이터 삭제 시 공간을 다시 사용 가능.
- 인덱스는 삭제된 자리에 DELETE MARK만 남기고, 실제 공간은 그대로 있음.
- 그래서 시간이 지나면:
  - 테이블 row 수: 줄어듦
  - 인덱스 row 수: 그대로 많음 → 불균형 발생
  - 즉, Table의 Data 수와 Index의 Data 수가 다를 수 있다.

3. `UPDATE`

- 인덱스는 기본적으로 변경이 불가능하다.
- 그래서 UPDATE는 내부적으로 아래와같이 동작
  - 기존 인덱스 레코드 삭제
  - 변경된 값으로 새 인덱스 레코드 삽입
  - 즉, UPDATE는 인덱스 입장에서 보면 DELETE + INSERT 작업 두 번 일어나는 것과 같아서 부하가 큼.
